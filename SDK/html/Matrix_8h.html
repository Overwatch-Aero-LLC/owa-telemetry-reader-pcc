<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Communications SDK: Matrix.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Communications SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Matrix_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrix.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Matrix operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a752e1496caba5e81ddce79a26195cad2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a752e1496caba5e81ddce79a26195cad2">SolveAugmentedMatrix</a> (double *pA, double *pb, double *px, int n)</td></tr>
<tr class="separator:a752e1496caba5e81ddce79a26195cad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed52384813a02e60211baec4a0c7026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a4ed52384813a02e60211baec4a0c7026">TransposeGeneral</a> (const double *pA, int rows, int cols, double *pB)</td></tr>
<tr class="separator:a4ed52384813a02e60211baec4a0c7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632ccdfbe6ec2faaa70d5da9737c7701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a632ccdfbe6ec2faaa70d5da9737c7701">TransposeSquare</a> (double *pA, int n)</td></tr>
<tr class="separator:a632ccdfbe6ec2faaa70d5da9737c7701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2f9f6adb3c91075195042af0eb3453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a5c2f9f6adb3c91075195042af0eb3453">TransposeSquaref</a> (float *pA, int n)</td></tr>
<tr class="separator:a5c2f9f6adb3c91075195042af0eb3453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6b0f31ace15408489be797ae6be7ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a5c6b0f31ace15408489be797ae6be7ac">MatrixMultiply</a> (const double *pA, int rowsA, int innerD, const double *pB, int colsB, double *pC)</td></tr>
<tr class="separator:a5c6b0f31ace15408489be797ae6be7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318b9c67d71153273a4b5987c1c338b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a318b9c67d71153273a4b5987c1c338b3">MatrixMultiplyf</a> (const float *pA, int rowsA, int innerD, const float *pB, int colsB, float *pC)</td></tr>
<tr class="separator:a318b9c67d71153273a4b5987c1c338b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab527a66c9d730d80bb7336d103c6d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aab527a66c9d730d80bb7336d103c6d6a">MatrixAdd</a> (const double *pA, const double *pB, int rows, int cols, double *pC)</td></tr>
<tr class="separator:aab527a66c9d730d80bb7336d103c6d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b29ece4f850436a9078a270e507237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a46b29ece4f850436a9078a270e507237">MatrixAddf</a> (const float *pA, const float *pB, int rows, int cols, float *pC)</td></tr>
<tr class="separator:a46b29ece4f850436a9078a270e507237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35ff4b551d85112aee95ab5d601eed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aa35ff4b551d85112aee95ab5d601eed0">MatrixMulScalar</a> (double a, const double *pA, int rows, int cols, double *pB)</td></tr>
<tr class="separator:aa35ff4b551d85112aee95ab5d601eed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed90aed624582d3ffa7726abd001614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a5ed90aed624582d3ffa7726abd001614">MatrixEye</a> (int rows, int cols, double *pA)</td></tr>
<tr class="separator:a5ed90aed624582d3ffa7726abd001614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9326ac8fc8fd42389b33327bdf483891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a9326ac8fc8fd42389b33327bdf483891">MatrixZeros</a> (int rows, int cols, double *pA)</td></tr>
<tr class="separator:a9326ac8fc8fd42389b33327bdf483891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac124cb186c4707f7cee4048c12447355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy</a> (const double *pA, int rows, int cols, double *pB)</td></tr>
<tr class="separator:ac124cb186c4707f7cee4048c12447355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb905d30ba26e421f58bf4e39f6bd6af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#afb905d30ba26e421f58bf4e39f6bd6af">MatrixDiag</a> (const double *pV, int dim, double *pA)</td></tr>
<tr class="separator:afb905d30ba26e421f58bf4e39f6bd6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566e815d75b1af2b4677310589a45ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a566e815d75b1af2b4677310589a45ea0">MatrixGetDiag</a> (const double *pA, int dim, double *pV)</td></tr>
<tr class="separator:a566e815d75b1af2b4677310589a45ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c490117c345513e83b092d2357865bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a2c490117c345513e83b092d2357865bc">ModChol</a> (const double *pP, int dim, double *pU, double *pD)</td></tr>
<tr class="separator:a2c490117c345513e83b092d2357865bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dcb843bd8e3e8f193807f054e32700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a66dcb843bd8e3e8f193807f054e32700">ModCholInv</a> (const double *pU, const double *pD, int dim, double *pP)</td></tr>
<tr class="separator:a66dcb843bd8e3e8f193807f054e32700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ee6f9b00905693e072a697b7e0fd04"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a66ee6f9b00905693e072a697b7e0fd04">VectorMagnitude</a> (const double *pV, int size)</td></tr>
<tr class="separator:a66ee6f9b00905693e072a697b7e0fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af732b35f911c9955647aacfefd9700fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#af732b35f911c9955647aacfefd9700fa">VectorNormalize</a> (const double *pV, int size, double *pVn)</td></tr>
<tr class="separator:af732b35f911c9955647aacfefd9700fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f124a91599a6fcaf8ea0b61a52fbf66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a5f124a91599a6fcaf8ea0b61a52fbf66">SubtractVectors</a> (const double Vector1[], const double Vector2[], double Result[], int size)</td></tr>
<tr class="separator:a5f124a91599a6fcaf8ea0b61a52fbf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb204d688ca8c8421d219a2840f3f5c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#afb204d688ca8c8421d219a2840f3f5c6">AddVectors</a> (const double Vector1[], const double Vector2[], double Result[], int size)</td></tr>
<tr class="separator:afb204d688ca8c8421d219a2840f3f5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ef9d2daa2b706b9e1e6081ef782113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a12ef9d2daa2b706b9e1e6081ef782113">MultiplyVectorByScaler</a> (double Scaler, const double Vector[], double Result[], int size)</td></tr>
<tr class="separator:a12ef9d2daa2b706b9e1e6081ef782113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1f0a2abd298f95ff20674e6dd506be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#abb1f0a2abd298f95ff20674e6dd506be">MatrixConcatenateV</a> (const double *pA, int rowsA, const double *pB, int rowsB, int cols, double *pC)</td></tr>
<tr class="separator:abb1f0a2abd298f95ff20674e6dd506be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d59a76d0839ed01e395e1bc0f81017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a97d59a76d0839ed01e395e1bc0f81017">MatrixConcatenateH</a> (const double *pA, int colsA, const double *pB, int colsB, int rows, double *pC)</td></tr>
<tr class="separator:a97d59a76d0839ed01e395e1bc0f81017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaee81f462e01444a05ef423cd6d82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aebaee81f462e01444a05ef423cd6d82e">MatrixUpperTriangular</a> (const double *pV, int dim, double *pA)</td></tr>
<tr class="separator:aebaee81f462e01444a05ef423cd6d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a02636d762222e2402238777105dc10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a1a02636d762222e2402238777105dc10">MatrixGetUpperTriangular</a> (const double *pA, int dim, double *pV)</td></tr>
<tr class="separator:a1a02636d762222e2402238777105dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca821088702529ef6afb22724cee195d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aca821088702529ef6afb22724cee195d">HouseQR</a> (const double *A, int rows, int cols, double *Q, double *R)</td></tr>
<tr class="separator:aca821088702529ef6afb22724cee195d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c12c13a186bca19fe9d6bd70c17210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a50c12c13a186bca19fe9d6bd70c17210">Chol</a> (const double *A, int size, double *R)</td></tr>
<tr class="separator:a50c12c13a186bca19fe9d6bd70c17210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d85edc3f9f5f9465907d38e43cd67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#ab8d85edc3f9f5f9465907d38e43cd67f">CholEx</a> (const double *A, int size, double *R, double *ATemp)</td></tr>
<tr class="separator:ab8d85edc3f9f5f9465907d38e43cd67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81b574e11fb6d5c7c4f83715f379354"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#ae81b574e11fb6d5c7c4f83715f379354">MatrixDet2</a> (const double A[4])</td></tr>
<tr class="separator:ae81b574e11fb6d5c7c4f83715f379354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90219e2ce3bca5f247ffb919a8631afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a90219e2ce3bca5f247ffb919a8631afb">MatrixInv2</a> (const double A[4], double Ainv[4])</td></tr>
<tr class="separator:a90219e2ce3bca5f247ffb919a8631afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8097b2aa0ae95883e68fae5d12ff1f30"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a8097b2aa0ae95883e68fae5d12ff1f30">MatrixDet3</a> (const double A[9])</td></tr>
<tr class="separator:a8097b2aa0ae95883e68fae5d12ff1f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d12f5301d560f6493169fee54ea23ea"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a7d12f5301d560f6493169fee54ea23ea">MatrixDet3f</a> (const float A[9])</td></tr>
<tr class="separator:a7d12f5301d560f6493169fee54ea23ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee20ff6a529ae47c5b4735b5926d0f7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aee20ff6a529ae47c5b4735b5926d0f7f">MatrixInv3</a> (const double A[9], double Ainv[9])</td></tr>
<tr class="separator:aee20ff6a529ae47c5b4735b5926d0f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c465fee2d6679bb4036fce1a319ce35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a7c465fee2d6679bb4036fce1a319ce35">MatrixInv3f</a> (const float A[9], float Ainv[9])</td></tr>
<tr class="separator:a7c465fee2d6679bb4036fce1a319ce35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4369eb78ec393fcf134889244b8290c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aa4369eb78ec393fcf134889244b8290c">MatrixDet4</a> (const double A[16])</td></tr>
<tr class="separator:aa4369eb78ec393fcf134889244b8290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb90e0a90f0d412ef36ed16d07aa5353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#adb90e0a90f0d412ef36ed16d07aa5353">MatrixInv4</a> (const double A[16], double Ainv[16])</td></tr>
<tr class="separator:adb90e0a90f0d412ef36ed16d07aa5353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dff441c1e150d4706df894a1a674aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aa5dff441c1e150d4706df894a1a674aa">MatrixInverse</a> (const double *A, int n, double *Ainv)</td></tr>
<tr class="separator:aa5dff441c1e150d4706df894a1a674aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a22a9de08e59b9a3a409bc393b56a1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a0a22a9de08e59b9a3a409bc393b56a1e">MatrixLUInverse</a> (const double *A, int n, double *Ainv)</td></tr>
<tr class="memdesc:a0a22a9de08e59b9a3a409bc393b56a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a matrix by LU factorization.  <a href="#a0a22a9de08e59b9a3a409bc393b56a1e">More...</a><br /></td></tr>
<tr class="separator:a0a22a9de08e59b9a3a409bc393b56a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43783ff7f462ee952921019c9ffb9019"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a43783ff7f462ee952921019c9ffb9019">MatrixLU</a> (const double *A, int n, double *LU, int *indx)</td></tr>
<tr class="memdesc:a43783ff7f462ee952921019c9ffb9019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize a square matrix into a lower-triangular and an upper-triangular matrix.  <a href="#a43783ff7f462ee952921019c9ffb9019">More...</a><br /></td></tr>
<tr class="separator:a43783ff7f462ee952921019c9ffb9019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cb08ef86b0de8f499642a5c3f4a1f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a93cb08ef86b0de8f499642a5c3f4a1f2">MatrixLUInPlace</a> (double *LU, int n, int *indx)</td></tr>
<tr class="memdesc:a93cb08ef86b0de8f499642a5c3f4a1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize a square matrix into LU form, in place.  <a href="#a93cb08ef86b0de8f499642a5c3f4a1f2">More...</a><br /></td></tr>
<tr class="separator:a93cb08ef86b0de8f499642a5c3f4a1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d3f89e186641277939bf0e811e33ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a01d3f89e186641277939bf0e811e33ab">BacksubLU</a> (const double *LU, const double *b, double *x, int *indx, int n)</td></tr>
<tr class="memdesc:a01d3f89e186641277939bf0e811e33ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system by back-substitution, for a system matrix given in LU form.  <a href="#a01d3f89e186641277939bf0e811e33ab">More...</a><br /></td></tr>
<tr class="separator:a01d3f89e186641277939bf0e811e33ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37f541633c6f75bf4459e5b950b899a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#af37f541633c6f75bf4459e5b950b899a">MatrixSumCols</a> (const double *A, int nRows, int nCols, double *v)</td></tr>
<tr class="separator:af37f541633c6f75bf4459e5b950b899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa5d0065706cb499297faea4b9276ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a0fa5d0065706cb499297faea4b9276ee">srotg</a> (double *sa, double *sb, double *c, double *s)</td></tr>
<tr class="separator:a0fa5d0065706cb499297faea4b9276ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb1fdd774f9b6760baba48d8189a1dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#aaeb1fdd774f9b6760baba48d8189a1dc">sdot</a> (const double *a, const double *b, int n)</td></tr>
<tr class="separator:aaeb1fdd774f9b6760baba48d8189a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8959f90906c7dbb9f0812b6f3a6c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#afc8959f90906c7dbb9f0812b6f3a6c40">schud</a> (const double *R, int n, const double *X, double *R1)</td></tr>
<tr class="separator:afc8959f90906c7dbb9f0812b6f3a6c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362083d3e4dc582afb4a3eb2e638475e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a362083d3e4dc582afb4a3eb2e638475e">schdd</a> (const double *R, int n, const double *X, double *R1)</td></tr>
<tr class="separator:a362083d3e4dc582afb4a3eb2e638475e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb08a6206b15fb91ada86d4608940673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#acb08a6206b15fb91ada86d4608940673">CholUpdate</a> (const double *R, int nR, const double *X, int mX, double u, double *R1)</td></tr>
<tr class="separator:acb08a6206b15fb91ada86d4608940673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ebdad473261ae2e1b04a2d8128218e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#ab0ebdad473261ae2e1b04a2d8128218e">SkewSymmetric3</a> (const double vec[3], double mat[9])</td></tr>
<tr class="memdesc:ab0ebdad473261ae2e1b04a2d8128218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 3x3 skew-symmetric matrix from a 3-element vector.  <a href="#ab0ebdad473261ae2e1b04a2d8128218e">More...</a><br /></td></tr>
<tr class="separator:ab0ebdad473261ae2e1b04a2d8128218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d4210694d0fa7b0c39f26fba670ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#ab4d4210694d0fa7b0c39f26fba670ecf">EigQR</a> (const double *A, int n, double *lambda, double *V)</td></tr>
<tr class="memdesc:ab4d4210694d0fa7b0c39f26fba670ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues and eigenvectors of a square matrix using QR algorithm.  <a href="#ab4d4210694d0fa7b0c39f26fba670ecf">More...</a><br /></td></tr>
<tr class="separator:ab4d4210694d0fa7b0c39f26fba670ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4a3bcc4d94584f210f3da131cd7e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#adbc4a3bcc4d94584f210f3da131cd7e1">MatrixNormInf</a> (const double *A, int rows, int cols)</td></tr>
<tr class="memdesc:adbc4a3bcc4d94584f210f3da131cd7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the infinity norm of a matrix.  <a href="#adbc4a3bcc4d94584f210f3da131cd7e1">More...</a><br /></td></tr>
<tr class="separator:adbc4a3bcc4d94584f210f3da131cd7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357b50c5458a0f6962c78a7177f9f1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#ae357b50c5458a0f6962c78a7177f9f1e">MatrixSqr</a> (const double *A, int nRows, int nCols, double *sqrA)</td></tr>
<tr class="memdesc:ae357b50c5458a0f6962c78a7177f9f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a matrix product of the form A'*A.  <a href="#ae357b50c5458a0f6962c78a7177f9f1e">More...</a><br /></td></tr>
<tr class="separator:ae357b50c5458a0f6962c78a7177f9f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af993d108eed079c89c713f50f2f0fa44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#af993d108eed079c89c713f50f2f0fa44">SVDcmpf</a> (float **A, int m, int n, float *W, float **V)</td></tr>
<tr class="memdesc:af993d108eed079c89c713f50f2f0fa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular value decomposition.  <a href="#af993d108eed079c89c713f50f2f0fa44">More...</a><br /></td></tr>
<tr class="separator:af993d108eed079c89c713f50f2f0fa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93901ebc537f7769dbf5073150b001d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Matrix_8h.html#a93901ebc537f7769dbf5073150b001d1">MatrixInverseSVDf</a> (float **A, int m, int n, float **Ainv)</td></tr>
<tr class="memdesc:a93901ebc537f7769dbf5073150b001d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo-inverse for non-square and singular matricies.  <a href="#a93901ebc537f7769dbf5073150b001d1">More...</a><br /></td></tr>
<tr class="separator:a93901ebc537f7769dbf5073150b001d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrix operations. </p>
<p>This module provides matrix functions such as multiplication, addition, transpose, etc. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afb204d688ca8c8421d219a2840f3f5c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVectors </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Vector1</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Vector2</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Result</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the sum of two vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vector1</td><td>points to a vector array. </td></tr>
    <tr><td class="paramname">Vector2</td><td>points to a vector array. </td></tr>
    <tr><td class="paramname">Result</td><td>points to space to receive the result. </td></tr>
    <tr><td class="paramname">size</td><td>is the number of elements in each vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01d3f89e186641277939bf0e811e33ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BacksubLU </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a linear system by back-substitution, for a system matrix given in LU form. </p>
<p>Back substitution for solving Lower/Upper decomposition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LU</td><td>points to the LU matrix </td></tr>
    <tr><td class="paramname">b</td><td>points to the boundary condition vector b </td></tr>
    <tr><td class="paramname">x</td><td>points to the solution vector x </td></tr>
    <tr><td class="paramname">indx</td><td>is the permutation vector. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BsplineCurve_8h.html#ada008b6f7856a3a95ef389f39826753f">ApproximateBsplineCurve()</a>, <a class="el" href="BsplineCurve_8h.html#aac8f1c4e06bf61d548b262974b918bb6">InterpolateBsplineCurve()</a>, and <a class="el" href="Matrix_8h.html#a0a22a9de08e59b9a3a409bc393b56a1e">MatrixLUInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a50c12c13a186bca19fe9d6bd70c17210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chol </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cholesky factorization of a square symmetric matrix. This function uses dynamic memory allocation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a square symmetric matrix. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of matrix A. </td></tr>
    <tr><td class="paramname">R</td><td>is the resulting upper-triangular Cholesky factor such that A = R'*R. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ab8d85edc3f9f5f9465907d38e43cd67f">CholEx()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8d85edc3f9f5f9465907d38e43cd67f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CholEx </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ATemp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cholesky factorization of a square symmetric matrix. This function uses caller supplied storage for temporary data space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a square symmetric matrix. </td></tr>
    <tr><td class="paramname">size</td><td>is the size of matrix A. </td></tr>
    <tr><td class="paramname">R</td><td>is the resulting upper-triangular Cholesky factor such that A = R'*R. </td></tr>
    <tr><td class="paramname">ATemp</td><td>points to temporary space equal in size to A. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, and <a class="el" href="Matrix_8c.html#a9326ac8fc8fd42389b33327bdf483891">MatrixZeros()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#a50c12c13a186bca19fe9d6bd70c17210">Chol()</a>.</p>

</div>
</div>
<a class="anchor" id="acb08a6206b15fb91ada86d4608940673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CholUpdate </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>R1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rank update of a Cholesky factorization. This computes the Cholesky factor R1 of the matrix A + sqrt(u)*X*X'(update) or A - sqrt(u)*X*X'(downdate), knowing R - the Cholesky factor of original matrix A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>is an upper-triangular Cholesky factor. </td></tr>
    <tr><td class="paramname">nR</td><td>is the size of matrix R. </td></tr>
    <tr><td class="paramname">X</td><td>is a column vector or a matrix. </td></tr>
    <tr><td class="paramname">mX</td><td>is the number of columns in X. </td></tr>
    <tr><td class="paramname">u</td><td>is the update factor (positive for an update, negative for a downdate). </td></tr>
    <tr><td class="paramname">R1</td><td>is the resulting upper-triangular Cholesky factor such that A +/- sqrt(u)*X*X' = R1'*R1. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, <a class="el" href="Matrix_8c.html#a362083d3e4dc582afb4a3eb2e638475e">schdd()</a>, <a class="el" href="Matrix_8c.html#afc8959f90906c7dbb9f0812b6f3a6c40">schud()</a>, and <a class="el" href="MathUtil_8h.html#a8f3cba07aa75b7320ae8bd6c0aeac498">sign()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4d4210694d0fa7b0c39f26fba670ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EigQR </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues and eigenvectors of a square matrix using QR algorithm. </p>
<p>Compute the eigenvalues and eigenvectors of a square matrix using QR algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a square matrix. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of rows/columns in matrix A. </td></tr>
    <tr><td class="paramname">lambda</td><td>is the vector of resulting eigenvalues. </td></tr>
    <tr><td class="paramname">V</td><td>is the matrix of resulting eigenvectors. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#aca821088702529ef6afb22724cee195d">HouseQR()</a>, <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, <a class="el" href="Matrix_8c.html#a5ed90aed624582d3ffa7726abd001614">MatrixEye()</a>, <a class="el" href="Matrix_8c.html#a5c6b0f31ace15408489be797ae6be7ac">MatrixMultiply()</a>, and <a class="el" href="Matrix_8c.html#adbc4a3bcc4d94584f210f3da131cd7e1">MatrixNormInf()</a>.</p>

</div>
</div>
<a class="anchor" id="aca821088702529ef6afb22724cee195d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HouseQR </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QR factorization using Householder reflections. Function returns Q and R such that A = Q*R. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix. </td></tr>
    <tr><td class="paramname">rows</td><td>is the number of rows in matrix A. </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns in matrix A. </td></tr>
    <tr><td class="paramname">Q</td><td>is an unitary matrix. </td></tr>
    <tr><td class="paramname">R</td><td>is an upper-triangular matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, <a class="el" href="Matrix_8c.html#a5ed90aed624582d3ffa7726abd001614">MatrixEye()</a>, and <a class="el" href="Matrix_8c.html#a5c6b0f31ace15408489be797ae6be7ac">MatrixMultiply()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#ab4d4210694d0fa7b0c39f26fba670ecf">EigQR()</a>.</p>

</div>
</div>
<a class="anchor" id="aab527a66c9d730d80bb7336d103c6d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixAdd </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add two matrices of the same size. The data in a matrix are stored such that A[row][col] = A[row*n + col]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>is a pointer to the first matrix A to be added </td></tr>
    <tr><td class="paramname">pB</td><td>is a pointer to the second matrix B to be added </td></tr>
    <tr><td class="paramname">rows</td><td>is the number of rows of matrices A and B </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns of matrices A and B </td></tr>
    <tr><td class="paramname">pC</td><td>is a pointer to the resulting matrix sum C = A + B. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#a2c490117c345513e83b092d2357865bc">ModChol()</a>.</p>

</div>
</div>
<a class="anchor" id="a46b29ece4f850436a9078a270e507237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixAddf </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add two matrices of the same size. The data in a matrix are stored such that A[row][col] = A[row*n + col]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>is a pointer to the first matrix A to be added </td></tr>
    <tr><td class="paramname">pB</td><td>is a pointer to the second matrix B to be added </td></tr>
    <tr><td class="paramname">rows</td><td>is the number of rows of matrices A and B </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns of matrices A and B </td></tr>
    <tr><td class="paramname">pC</td><td>is a pointer to the resulting matrix sum C = A + B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97d59a76d0839ed01e395e1bc0f81017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixConcatenateH </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate two matrices horizontally C = [A B] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>is a pointer to the first matrix A </td></tr>
    <tr><td class="paramname">colsA</td><td>is the number of columns in matrix A </td></tr>
    <tr><td class="paramname">pB</td><td>is a pointer to the second matrix B </td></tr>
    <tr><td class="paramname">colsB</td><td>is the number of columns in matrix B </td></tr>
    <tr><td class="paramname">rows</td><td>is the number of rows of both A and B (must be equal) </td></tr>
    <tr><td class="paramname">pC</td><td>is a pointer to the resulting block matrix C of size rows x (colsA+colsB) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb1f0a2abd298f95ff20674e6dd506be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixConcatenateV </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate two matrices vertically C = [A; B] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>is a pointer to the first matrix A </td></tr>
    <tr><td class="paramname">rowsA</td><td>is the number of rows in matrix A </td></tr>
    <tr><td class="paramname">pB</td><td>is a pointer to the second matrix B </td></tr>
    <tr><td class="paramname">rowsB</td><td>is the number of rows in matrix B </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns of both A and B (must be equal) </td></tr>
    <tr><td class="paramname">pC</td><td>is a pointer to the resulting block matrix C of size (rowsA+rowsB) x cols </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac124cb186c4707f7cee4048c12447355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCopy </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the elements from a matrix A to a matrix B. Both matrices must have the same size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>is a pointer to the source matrix A </td></tr>
    <tr><td class="paramname">rows</td><td>is the number of rows in the source and destination matrices </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns in the source and destination matrices </td></tr>
    <tr><td class="paramname">pB</td><td>is a pointer to the destination matrix B = A </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#ab8d85edc3f9f5f9465907d38e43cd67f">CholEx()</a>, <a class="el" href="Matrix_8h.html#acb08a6206b15fb91ada86d4608940673">CholUpdate()</a>, <a class="el" href="Matrix_8h.html#ab4d4210694d0fa7b0c39f26fba670ecf">EigQR()</a>, <a class="el" href="Matrix_8h.html#aca821088702529ef6afb22724cee195d">HouseQR()</a>, <a class="el" href="Matrix_8h.html#a43783ff7f462ee952921019c9ffb9019">MatrixLU()</a>, <a class="el" href="Matrix_8h.html#a2c490117c345513e83b092d2357865bc">ModChol()</a>, <a class="el" href="Matrix_8h.html#a66dcb843bd8e3e8f193807f054e32700">ModCholInv()</a>, <a class="el" href="Matrix_8h.html#a362083d3e4dc582afb4a3eb2e638475e">schdd()</a>, and <a class="el" href="Matrix_8h.html#afc8959f90906c7dbb9f0812b6f3a6c40">schud()</a>.</p>

</div>
</div>
<a class="anchor" id="ae81b574e11fb6d5c7c4f83715f379354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatrixDet2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>A</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The determinant of a 2x2 matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the determinant. </dd></dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#a90219e2ce3bca5f247ffb919a8631afb">MatrixInv2()</a>.</p>

</div>
</div>
<a class="anchor" id="a8097b2aa0ae95883e68fae5d12ff1f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatrixDet3 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>A</em>[9]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The determinant of a 3x3 matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the determinant. </dd></dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#aee20ff6a529ae47c5b4735b5926d0f7f">MatrixInv3()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d12f5301d560f6493169fee54ea23ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MatrixDet3f </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>A</em>[9]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The determinant of a 3x3 matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the determinant. </dd></dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#a7c465fee2d6679bb4036fce1a319ce35">MatrixInv3f()</a>.</p>

</div>
</div>
<a class="anchor" id="aa4369eb78ec393fcf134889244b8290c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatrixDet4 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>A</em>[16]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the determinant of a 4x4 matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the determinant. </dd></dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#adb90e0a90f0d412ef36ed16d07aa5353">MatrixInv4()</a>.</p>

</div>
</div>
<a class="anchor" id="afb905d30ba26e421f58bf4e39f6bd6af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixDiag </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a square matrix and copy the elements from vector V to the main diagonal of matrix A. The rest of elements in matrix A will be initialized to zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pV</td><td>is a pointer to the source vector V </td></tr>
    <tr><td class="paramname">dim</td><td>is the dimension of the vector V </td></tr>
    <tr><td class="paramname">pA</td><td>is a pointer to the resulting diagonal matrix A. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a9326ac8fc8fd42389b33327bdf483891">MatrixZeros()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ed90aed624582d3ffa7726abd001614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixEye </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an identity matrix. If the matrix is not square, then the additional rows or columns will contain only zeros. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>is the number of rows of the identity matrix </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns of the identity matrix </td></tr>
    <tr><td class="paramname">pA</td><td>is a pointer to the resulting identity matrix A </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#ab4d4210694d0fa7b0c39f26fba670ecf">EigQR()</a>, <a class="el" href="attitude_8h.html#a025b06205c84766a00c48a5061393725">GetNavToBodyMatFromVec()</a>, and <a class="el" href="Matrix_8h.html#aca821088702529ef6afb22724cee195d">HouseQR()</a>.</p>

</div>
</div>
<a class="anchor" id="a566e815d75b1af2b4677310589a45ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixGetDiag </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the diagonal of a square matrix and return it as a vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>is a pointer to a square matrix A </td></tr>
    <tr><td class="paramname">dim</td><td>is the dimension of the matrix A (row = col) </td></tr>
    <tr><td class="paramname">pV</td><td>is the diagonal of matrix A returned as a vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a02636d762222e2402238777105dc10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixGetUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a vector of elements from a square upper-triangular matrix. For example, an upper-triangular matrix: A = [a11 a12 a13; 0 a22 a23; 0 0 a33] will result in a vector V = [a11 a12 a13 a22 a23 a33]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>is a pointer to the upper-triangular matrix. </td></tr>
    <tr><td class="paramname">dim</td><td>is the matrix size. </td></tr>
    <tr><td class="paramname">pV</td><td>points to space to receive the resulting vector with data. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a9326ac8fc8fd42389b33327bdf483891">MatrixZeros()</a>, <a class="el" href="MathUtil_8h.html#a8f3cba07aa75b7320ae8bd6c0aeac498">sign()</a>, and <a class="el" href="Matrix_8c.html#a66ee6f9b00905693e072a697b7e0fd04">VectorMagnitude()</a>.</p>

</div>
</div>
<a class="anchor" id="a90219e2ce3bca5f247ffb919a8631afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixInv2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>A</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ainv</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The inverse of a 2x2 matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix which will be inverted. </td></tr>
    <tr><td class="paramname">Ainv</td><td>points to space to receive the inverse of matrix A. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ae81b574e11fb6d5c7c4f83715f379354">MatrixDet2()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#aa5dff441c1e150d4706df894a1a674aa">MatrixInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="aee20ff6a529ae47c5b4735b5926d0f7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixInv3 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>A</em>[9], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ainv</em>[9]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The inverse of a 3x3 matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix which will be inverted. </td></tr>
    <tr><td class="paramname">Ainv</td><td>points to space to receive the inverse of matrix A. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a8097b2aa0ae95883e68fae5d12ff1f30">MatrixDet3()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#aa5dff441c1e150d4706df894a1a674aa">MatrixInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c465fee2d6679bb4036fce1a319ce35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixInv3f </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>A</em>[9], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Ainv</em>[9]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The inverse of a 3x3 matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix which will be inverted. </td></tr>
    <tr><td class="paramname">Ainv</td><td>points to space to receive the inverse of matrix A. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a7d12f5301d560f6493169fee54ea23ea">MatrixDet3f()</a>.</p>

</div>
</div>
<a class="anchor" id="adb90e0a90f0d412ef36ed16d07aa5353"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixInv4 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>A</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Ainv</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The inverse of a 4x4 matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix which will be inverted. </td></tr>
    <tr><td class="paramname">Ainv</td><td>points to space to receive the inverse of matrix A. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#aa4369eb78ec393fcf134889244b8290c">MatrixDet4()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#aa5dff441c1e150d4706df894a1a674aa">MatrixInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5dff441c1e150d4706df894a1a674aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixInverse </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Ainv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the inverse of a square matrix. Uses explicit formulas if the matrix is 1x1, 2x2, or 3x3, and an LU factorization otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix which will be inverted. </td></tr>
    <tr><td class="paramname">n</td><td>is the matrix size. </td></tr>
    <tr><td class="paramname">Ainv</td><td>points to space to receive the inverse of matrix A. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a90219e2ce3bca5f247ffb919a8631afb">MatrixInv2()</a>, <a class="el" href="Matrix_8c.html#aee20ff6a529ae47c5b4735b5926d0f7f">MatrixInv3()</a>, <a class="el" href="Matrix_8c.html#adb90e0a90f0d412ef36ed16d07aa5353">MatrixInv4()</a>, and <a class="el" href="Matrix_8c.html#a0a22a9de08e59b9a3a409bc393b56a1e">MatrixLUInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a93901ebc537f7769dbf5073150b001d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatrixInverseSVDf </td>
          <td>(</td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>Ainv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pseudo-inverse for non-square and singular matricies. </p>

<p>References <a class="el" href="Matrix_8c.html#af993d108eed079c89c713f50f2f0fa44">SVDcmpf()</a>.</p>

</div>
</div>
<a class="anchor" id="a43783ff7f462ee952921019c9ffb9019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatrixLU </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factorize a square matrix into a lower-triangular and an upper-triangular matrix. </p>
<p>Decompose a matrix A into a lower-triangular matrix L and an upper-triangular matrix U, such that A = L*U. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the source matrix. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of rows and columns of A. </td></tr>
    <tr><td class="paramname">LU</td><td>points to space to receive the decomposed matrix </td></tr>
    <tr><td class="paramname">indx</td><td>receives the permutations vector. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, and <a class="el" href="Matrix_8c.html#a93cb08ef86b0de8f499642a5c3f4a1f2">MatrixLUInPlace()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#a0a22a9de08e59b9a3a409bc393b56a1e">MatrixLUInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a93cb08ef86b0de8f499642a5c3f4a1f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatrixLUInPlace </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factorize a square matrix into LU form, in place. </p>
<p>Decompose a matrix A into a lower-triangular matrix L and an upper-triangular matrix U, such that A = L*U. The factorization is done in-place, operating directly on the input matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LU</td><td>points to a square matrix that will be factorized in-place. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of rows and columns of A. </td></tr>
    <tr><td class="paramname">indx</td><td>receives the permutations vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BsplineCurve_8h.html#ada008b6f7856a3a95ef389f39826753f">ApproximateBsplineCurve()</a>, <a class="el" href="BsplineCurve_8h.html#aac8f1c4e06bf61d548b262974b918bb6">InterpolateBsplineCurve()</a>, and <a class="el" href="Matrix_8h.html#a43783ff7f462ee952921019c9ffb9019">MatrixLU()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a22a9de08e59b9a3a409bc393b56a1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatrixLUInverse </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Ainv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert a matrix by LU factorization. </p>
<p>Invert a matrix by LU factorization and back substitution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the matrix to invert. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of rows and columns of A. </td></tr>
    <tr><td class="paramname">Ainv</td><td>points to space to received the inverted matrix </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a01d3f89e186641277939bf0e811e33ab">BacksubLU()</a>, and <a class="el" href="Matrix_8c.html#a43783ff7f462ee952921019c9ffb9019">MatrixLU()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#aa5dff441c1e150d4706df894a1a674aa">MatrixInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="aa35ff4b551d85112aee95ab5d601eed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixMulScalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply a matrix with a scalar. The data in a matrix are stored such that A[row][col] = A[row*n + col]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the scalar </td></tr>
    <tr><td class="paramname">pA</td><td>is a pointer to the matrix A </td></tr>
    <tr><td class="paramname">rows</td><td>is the number of rows in matrix A </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns in matrix A </td></tr>
    <tr><td class="paramname">pB</td><td>is a pointer to the resulting matrix B = a*A </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#a2c490117c345513e83b092d2357865bc">ModChol()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c6b0f31ace15408489be797ae6be7ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatrixMultiply </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>innerD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply matrix A by matrix B (A x B) and put the resutl into matrix C. The data in a matrix are stored such that A[row][col] = A[row*n + col]. Note: by the definition of matrix multiplication, rows of B must be equal to the cols of A. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example:    |A00,A01,A02|   |B00,B01,B02,B03|   |C00,C01,C02,C03|</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;            |A10,A11,A12| x |B10,B11,B12,B13| = |C10,C11,C12,C13|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            |A20,A21,A22|   |B20,B21,B22,B23|   |C20,C21,C22,C23|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;            |A30,A31,A32| innerD = 3, colsB = 4 |C30,C31,C32,C33|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            |A40,A41,A42|                       |C40,C41,C42,C43|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            |A50,A51,A52|                       |C50,C51,C52,C53|</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;            rowsA = 6, innerD = 3               rowsA x colsB</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        where: C13 = A10*B03 + A11*B13 + A12*B23</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        Cij = scalar product of ith row of A by jth col of B</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>points to the matrix A. </td></tr>
    <tr><td class="paramname">rowsA</td><td>is the number of rows in matrix A. </td></tr>
    <tr><td class="paramname">innerD</td><td>is the number of columns in matrix A and number of rows in matrix B. </td></tr>
    <tr><td class="paramname">pB</td><td>points to the matrix B. </td></tr>
    <tr><td class="paramname">colsB</td><td>is the number of columns in matrix B. </td></tr>
    <tr><td class="paramname">pC</td><td>points to the solution space which must be large enough to hold rowsA x colsB elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nonzero if successful. </dd></dl>

<p>Referenced by <a class="el" href="Rotations_8h.html#a9281e9c1d72cb85e2aadc796f5c6639c">CreateRotationEx()</a>, <a class="el" href="Matrix_8h.html#ab4d4210694d0fa7b0c39f26fba670ecf">EigQR()</a>, <a class="el" href="attitude_8h.html#a025b06205c84766a00c48a5061393725">GetNavToBodyMatFromVec()</a>, <a class="el" href="Matrix_8h.html#aca821088702529ef6afb22724cee195d">HouseQR()</a>, <a class="el" href="Matrix_8h.html#a66dcb843bd8e3e8f193807f054e32700">ModCholInv()</a>, <a class="el" href="attitude_8h.html#ac9d98e120a6cfdafffbb499055d37e56">RotateBody2Nav()</a>, and <a class="el" href="attitude_8h.html#ac125d085162e14e8e7a05f34c832b5fa">RotateNav2Body()</a>.</p>

</div>
</div>
<a class="anchor" id="a318b9c67d71153273a4b5987c1c338b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MatrixMultiplyf </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>innerD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply matrix A by matrix B (A x B) and put the resutl into matrix C. The data in a matrix are stored such that A[row][col] = A[row*n + col]. Note: by the definition of matrix multiplication, rows of B must be equal to the cols of A. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example:    |A00,A01,A02|   |B00,B01,B02,B03|   |C00,C01,C02,C03|</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;            |A10,A11,A12| x |B10,B11,B12,B13| = |C10,C11,C12,C13|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            |A20,A21,A22|   |B20,B21,B22,B23|   |C20,C21,C22,C23|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;            |A30,A31,A32| innerD = 3, colsB = 4 |C30,C31,C32,C33|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            |A40,A41,A42|                       |C40,C41,C42,C43|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            |A50,A51,A52|                       |C50,C51,C52,C53|</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;            rowsA = 6, innerD = 3               rowsA x colsB</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        where: C13 = A10*B03 + A11*B13 + A12*B23</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        Cij = scalar product of ith row of A by jth col of B</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>points to the matrix A. </td></tr>
    <tr><td class="paramname">rowsA</td><td>is the number of rows in matrix A. </td></tr>
    <tr><td class="paramname">innerD</td><td>is the number of columns in matrix A and number of rows in matrix B. </td></tr>
    <tr><td class="paramname">pB</td><td>points to the matrix B. </td></tr>
    <tr><td class="paramname">colsB</td><td>is the number of columns in matrix B. </td></tr>
    <tr><td class="paramname">pC</td><td>points to the solution space which must be large enough to hold rowsA x colsB elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nonzero if successful. </dd></dl>

<p>Referenced by <a class="el" href="Rotations_8h.html#ae4f10845959051502db2e9f2707dd590">CreateRotationExf()</a>, <a class="el" href="attitude_8h.html#a01a7f023a5908bb347324e5639ee7f11">RotateBody2Navf()</a>, and <a class="el" href="attitude_8h.html#a0b046fd2f202560bffe64d63831d8df6">RotateNav2Bodyf()</a>.</p>

</div>
</div>
<a class="anchor" id="adbc4a3bcc4d94584f210f3da131cd7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatrixNormInf </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the infinity norm of a matrix. </p>
<p>Get the infinity norm of a matrix, which is the largest row sum of absolute values of matrix elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix. </td></tr>
    <tr><td class="paramname">rows</td><td>is the number of rows in A. </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns in A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The infinity norm of A. </dd></dl>

<p>References <a class="el" href="MathUtil_8h.html#a814897d67672a04ec3b8d9ef3af0fefc">maximum()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#ab4d4210694d0fa7b0c39f26fba670ecf">EigQR()</a>.</p>

</div>
</div>
<a class="anchor" id="ae357b50c5458a0f6962c78a7177f9f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixSqr </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sqrA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a matrix product of the form A'*A. </p>
<p>Calculate a matrix product of the form A'*A. This efficient algorithm calculates only the upper triangle of the square matrix, since the multiplication results in a square, symmetric matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the input matrix, of arbitrary dimensions. </td></tr>
    <tr><td class="paramname">nRows</td><td>is the number of rows in A. </td></tr>
    <tr><td class="paramname">nCols</td><td>is the number of columns in A. </td></tr>
    <tr><td class="paramname">sqrA</td><td>is the resulting matrix M = A'*A. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BsplineCurve_8h.html#ada008b6f7856a3a95ef389f39826753f">ApproximateBsplineCurve()</a>.</p>

</div>
</div>
<a class="anchor" id="af37f541633c6f75bf4459e5b950b899a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixSumCols </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the columns of a matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>points to the source matrix. </td></tr>
    <tr><td class="paramname">nRows</td><td>is the number of rows in matrix A. </td></tr>
    <tr><td class="paramname">nCols</td><td>is the number of columns in matrix A. </td></tr>
    <tr><td class="paramname">v</td><td>points to space to receive the resulting vector. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a9326ac8fc8fd42389b33327bdf483891">MatrixZeros()</a>.</p>

</div>
</div>
<a class="anchor" id="aebaee81f462e01444a05ef423cd6d82e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a square upper-triangular matrix with elements from a vector. The matrix is populated in a left-to-right row fashion. For example, a vector with 6 elements: V = [a1 a2 a3 a4 a5 a6] will result in an upper-triangular matrix: A = [a1 a2 a3; 0 a4 a5; 0 0 a6]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pV</td><td>is the vector with data. </td></tr>
    <tr><td class="paramname">dim</td><td>is the matrix size. </td></tr>
    <tr><td class="paramname">pA</td><td>is a pointer to the resulting upper-triangular matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a9326ac8fc8fd42389b33327bdf483891">MatrixZeros()</a>.</p>

</div>
</div>
<a class="anchor" id="a9326ac8fc8fd42389b33327bdf483891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixZeros </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a matrix of zeros. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>is the number of rows of the matrix </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns of the matrix </td></tr>
    <tr><td class="paramname">pA</td><td>is a pointer to the resulting matrix A </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#ab8d85edc3f9f5f9465907d38e43cd67f">CholEx()</a>, <a class="el" href="Matrix_8h.html#afb905d30ba26e421f58bf4e39f6bd6af">MatrixDiag()</a>, <a class="el" href="Matrix_8h.html#a1a02636d762222e2402238777105dc10">MatrixGetUpperTriangular()</a>, <a class="el" href="Matrix_8h.html#af37f541633c6f75bf4459e5b950b899a">MatrixSumCols()</a>, <a class="el" href="Matrix_8h.html#aebaee81f462e01444a05ef423cd6d82e">MatrixUpperTriangular()</a>, and <a class="el" href="Matrix_8h.html#a2c490117c345513e83b092d2357865bc">ModChol()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c490117c345513e83b092d2357865bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModChol </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the modified Cholesky factors U, D of symmetric positive definite matrix P such that U is unit upper triangular, D is diagonal and P = U*D*U' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pP</td><td>is a pointer to the symmetric positive-definite matrix P </td></tr>
    <tr><td class="paramname">dim</td><td>is the number of rows/columns in matrix P </td></tr>
    <tr><td class="paramname">pU</td><td>is a pointer to the resulting upper-triangular matrix U </td></tr>
    <tr><td class="paramname">pD</td><td>is a pointer to the resulting diagonal matrix D </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#aab527a66c9d730d80bb7336d103c6d6a">MatrixAdd()</a>, <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, <a class="el" href="Matrix_8c.html#aa35ff4b551d85112aee95ab5d601eed0">MatrixMulScalar()</a>, <a class="el" href="Matrix_8c.html#a9326ac8fc8fd42389b33327bdf483891">MatrixZeros()</a>, and <a class="el" href="Matrix_8c.html#a632ccdfbe6ec2faaa70d5da9737c7701">TransposeSquare()</a>.</p>

</div>
</div>
<a class="anchor" id="a66dcb843bd8e3e8f193807f054e32700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModCholInv </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute P = U*D*U'. This is the reverse of the transformation <a class="el" href="Matrix_8c.html#a2c490117c345513e83b092d2357865bc">ModChol()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pU</td><td>is a pointer to the upper-triangular Cholesky factor U </td></tr>
    <tr><td class="paramname">pD</td><td>is a pointer to the diagonal Cholesky factor D </td></tr>
    <tr><td class="paramname">dim</td><td>is the size of the matrices U, D, and P </td></tr>
    <tr><td class="paramname">pP</td><td>is a pointer to the symmetric positive-definite matrix P </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, <a class="el" href="Matrix_8c.html#a5c6b0f31ace15408489be797ae6be7ac">MatrixMultiply()</a>, and <a class="el" href="Matrix_8c.html#a632ccdfbe6ec2faaa70d5da9737c7701">TransposeSquare()</a>.</p>

</div>
</div>
<a class="anchor" id="a12ef9d2daa2b706b9e1e6081ef782113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiplyVectorByScaler </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Scaler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Vector</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Result</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the result of a vector multiplied by a scaler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Scaler</td><td>is the scale factor to apply to the vector </td></tr>
    <tr><td class="paramname">Vector</td><td>points to a vector array to be multiplied. </td></tr>
    <tr><td class="paramname">Result</td><td>points to space to receive the result, this can be the same as Vector. </td></tr>
    <tr><td class="paramname">size</td><td>is the number of elements in each vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a362083d3e4dc582afb4a3eb2e638475e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schdd </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>R1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cholesky factor downdate. This computes the Cholesky factor R1 of the matrix A - X*X', knowing R - the Cholesky factor of original matrix A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>is an upper-triangular Cholesky factor. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of matrix R. </td></tr>
    <tr><td class="paramname">X</td><td>is a column vector or a matrix. </td></tr>
    <tr><td class="paramname">R1</td><td>is the resulting upper-triangular Cholesky factor such that A - X*X' = R1'*R1. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, <a class="el" href="Matrix_8c.html#aaeb1fdd774f9b6760baba48d8189a1dc">sdot()</a>, <a class="el" href="MathUtil_8h.html#a22f4e97ed7ca9e188dc4e074a1b2e5a7">sqr()</a>, and <a class="el" href="Matrix_8c.html#a66ee6f9b00905693e072a697b7e0fd04">VectorMagnitude()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#acb08a6206b15fb91ada86d4608940673">CholUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="afc8959f90906c7dbb9f0812b6f3a6c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schud </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>R1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cholesky factor update. This computes the Cholesky factor R1 of the matrix A + X*X', knowing R - the Cholesky factor of original matrix A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>is an upper-triangular Cholesky factor. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of matrix R. </td></tr>
    <tr><td class="paramname">X</td><td>is a column vector or a matrix. </td></tr>
    <tr><td class="paramname">R1</td><td>is the resulting upper-triangular Cholesky factor such that A + X*X' = R1'*R1. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#ac124cb186c4707f7cee4048c12447355">MatrixCopy()</a>, and <a class="el" href="Matrix_8c.html#a0fa5d0065706cb499297faea4b9276ee">srotg()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#acb08a6206b15fb91ada86d4608940673">CholUpdate()</a>.</p>

</div>
</div>
<a class="anchor" id="aaeb1fdd774f9b6760baba48d8189a1dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sdot </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dot product of two vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>points to the first vector. </td></tr>
    <tr><td class="paramname">b</td><td>points to the second vector. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of elements in each vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product of the two vectors. </dd></dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#a362083d3e4dc582afb4a3eb2e638475e">schdd()</a>.</p>

</div>
</div>
<a class="anchor" id="ab0ebdad473261ae2e1b04a2d8128218e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkewSymmetric3 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>vec</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mat</em>[9]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 3x3 skew-symmetric matrix from a 3-element vector. </p>
<p>Create a 3x3 skew-symmetric matrix from a 3x1 vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>= the 3x1 input vector </td></tr>
    <tr><td class="paramname">mat</td><td>= the 3x3 matrix result </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="attitude_8h.html#a025b06205c84766a00c48a5061393725">GetNavToBodyMatFromVec()</a>.</p>

</div>
</div>
<a class="anchor" id="a752e1496caba5e81ddce79a26195cad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SolveAugmentedMatrix </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use Gaussian elimination and backsolving to find the solution vector x in Ax = b, where x is a square matrix of size n. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example:    |A00,A01,A02,A03| |x0| |b0|</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;            |A10,A11,A12,A13| |x1| |b1|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            |A20,A21,A22,A23|*|x2|=|b2|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;            |A30,A31,A32,A33| |x3| |b3| : n=4</div></div><!-- fragment --><p> The data in A are stored such that A[row][col] = A[row*n + col]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>points to the matrix A. </td></tr>
    <tr><td class="paramname">pb</td><td>points to the boundary condition vector b </td></tr>
    <tr><td class="paramname">px</td><td>points to the solution vector x </td></tr>
    <tr><td class="paramname">n</td><td>is the integer size of the matrix, n by n. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for singular matrices, else nonzero </dd></dl>

</div>
</div>
<a class="anchor" id="a0fa5d0065706cb499297faea4b9276ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srotg </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Givens rotation. </p>

<p>References <a class="el" href="MathUtil_8h.html#a8f3cba07aa75b7320ae8bd6c0aeac498">sign()</a>.</p>

<p>Referenced by <a class="el" href="Matrix_8h.html#afc8959f90906c7dbb9f0812b6f3a6c40">schud()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f124a91599a6fcaf8ea0b61a52fbf66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SubtractVectors </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Vector1</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>Vector2</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Result</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the difference between two vectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vector1</td><td>points to a vector array. </td></tr>
    <tr><td class="paramname">Vector2</td><td>points to a vector array. </td></tr>
    <tr><td class="paramname">Result</td><td>points to space to receive the result </td></tr>
    <tr><td class="paramname">size</td><td>is the number of elements in each vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af993d108eed079c89c713f50f2f0fa44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SVDcmpf </td>
          <td>(</td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singular value decomposition. </p>

<p>Referenced by <a class="el" href="Matrix_8h.html#a93901ebc537f7769dbf5073150b001d1">MatrixInverseSVDf()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed52384813a02e60211baec4a0c7026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TransposeGeneral </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the transpose of a general matrix A and put the result into the matrix B. The data in A are stored such that A[row][col] = A[row*n + col]. A and B must not be colocated in memory. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example:    |A00,A01,A02|</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;            |A10,A11,A12|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            |A20,A21,A22|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;            |A30,A31,A32|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            |A40,A41,A42|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            |A50,A51,A52| rows = 6, cols = 3</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;becomes:</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;            |A00,A10,A20,A30,A40|</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;            |A01,A11,A21,A31,A41|</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;            |A02,A12,A22,A32,A42| rows = 3, cols = 6</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>points to the matrix A </td></tr>
    <tr><td class="paramname">rows</td><td>is the integer number of rows in A. </td></tr>
    <tr><td class="paramname">cols</td><td>is the integer number of columns in A. </td></tr>
    <tr><td class="paramname">pB</td><td>points to storage for the result matrix B </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a632ccdfbe6ec2faaa70d5da9737c7701"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TransposeSquare </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the transpose of a square matrix A, putting the result back into A. If you want to preserve what is in A, call <a class="el" href="Matrix_8c.html#a4ed52384813a02e60211baec4a0c7026">TransposeGeneral()</a>. The data in A are stored such that A[row][col] = A[row*n + col]. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example:    |A00,A01,A02|</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;            |A10,A11,A12|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            |A20,A21,A22| n x n</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;becomes:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            |A00,A10,A20|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            |A01,A11,A21|</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;            |A02,A12,A22| n x n</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>points to the matrix A </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the matrix, n x n </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="BsplineCurve_8h.html#aac8f1c4e06bf61d548b262974b918bb6">InterpolateBsplineCurve()</a>, <a class="el" href="Matrix_8h.html#a2c490117c345513e83b092d2357865bc">ModChol()</a>, and <a class="el" href="Matrix_8h.html#a66dcb843bd8e3e8f193807f054e32700">ModCholInv()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c2f9f6adb3c91075195042af0eb3453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TransposeSquaref </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the transpose of a square matrix A, putting the result back into A. If you want to preserve what is in A, call <a class="el" href="Matrix_8c.html#a4ed52384813a02e60211baec4a0c7026">TransposeGeneral()</a>. The data in A are stored such that A[row][col] = A[row*n + col]. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;example:    |A00,A01,A02|</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;            |A10,A11,A12|</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;            |A20,A21,A22| n x n</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;becomes:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;            |A00,A10,A20|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;            |A01,A11,A21|</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;            |A02,A12,A22| n x n</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pA</td><td>points to the matrix A </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the matrix, n x n </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66ee6f9b00905693e072a697b7e0fd04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double VectorMagnitude </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the magnitude of a vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pV</td><td>is a pointer to the vector </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The magnitude of the vector </dd></dl>

<p>Referenced by <a class="el" href="Matrix_8h.html#a1a02636d762222e2402238777105dc10">MatrixGetUpperTriangular()</a>, <a class="el" href="Matrix_8h.html#a362083d3e4dc582afb4a3eb2e638475e">schdd()</a>, and <a class="el" href="Matrix_8h.html#af732b35f911c9955647aacfefd9700fa">VectorNormalize()</a>.</p>

</div>
</div>
<a class="anchor" id="af732b35f911c9955647aacfefd9700fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VectorNormalize </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalize a vector by dividing its elements by its magnitude </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pV</td><td>is a pointer to the original vector </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the vector </td></tr>
    <tr><td class="paramname">pVn</td><td>is a pointer to the normalized vector, this can be the same as pV </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Matrix_8c.html#a66ee6f9b00905693e072a697b7e0fd04">VectorMagnitude()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_6858287c2095cbe2cb1b47261e44fa7a.html">All</a></li><li class="navelem"><a class="el" href="Matrix_8h.html">Matrix.h</a></li>
    <li class="footer">Generated on Wed Aug 2 2017 09:25:44 for Communications SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>

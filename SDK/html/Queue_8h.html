<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Communications SDK: Queue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Communications SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Queue_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>First in first out ring buffer queues for 8-bit data.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;Types.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structQueue__t.html">Queue_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33605d1c942e81951eecc51f66cef7af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ</a> (UInt32 Size)</td></tr>
<tr class="separator:a33605d1c942e81951eecc51f66cef7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea93c75bda73855de0af7ff9b3f1e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a7fea93c75bda73855de0af7ff9b3f1e1">DestroyQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:a7fea93c75bda73855de0af7ff9b3f1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe54943f8deb0ebb76cab0642c47772f"><td class="memItemLeft" align="right" valign="top">SInt16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#abe54943f8deb0ebb76cab0642c47772f">DeQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:abe54943f8deb0ebb76cab0642c47772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7260b3138e9acc3591b2b95e2c4efcab"><td class="memItemLeft" align="right" valign="top">SInt16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a7260b3138e9acc3591b2b95e2c4efcab">DeQFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:a7260b3138e9acc3591b2b95e2c4efcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd462a4f5135461aa18fc6e6e7552ded"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#acd462a4f5135461aa18fc6e6e7552ded">BlockDeQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt8 *pData, UInt32 Size)</td></tr>
<tr class="separator:acd462a4f5135461aa18fc6e6e7552ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dcebd0a612619b8149ac1905b4b5ab"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a63dcebd0a612619b8149ac1905b4b5ab">BlockDeQFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt8 *pData, UInt32 Size)</td></tr>
<tr class="separator:a63dcebd0a612619b8149ac1905b4b5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263d0bc6499f82331868576aa095592d"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a263d0bc6499f82331868576aa095592d">ReverseDeQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt32 Size)</td></tr>
<tr class="separator:a263d0bc6499f82331868576aa095592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be71d93fc5d5f35042c52d3c179ae9c"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a0be71d93fc5d5f35042c52d3c179ae9c">ReverseDeQFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt32 Size)</td></tr>
<tr class="separator:a0be71d93fc5d5f35042c52d3c179ae9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac520b06dbb8d4f0cf5fc5c560202a996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#ac520b06dbb8d4f0cf5fc5c560202a996">EnQFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt8 Data)</td></tr>
<tr class="separator:ac520b06dbb8d4f0cf5fc5c560202a996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af291243469b7aa1b704317e199407abd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#af291243469b7aa1b704317e199407abd">EnQSuperFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt8 Data)</td></tr>
<tr class="separator:af291243469b7aa1b704317e199407abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384132c5c0d4700689eb5c93124dbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a2384132c5c0d4700689eb5c93124dbfa">EnQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt8 Data)</td></tr>
<tr class="separator:a2384132c5c0d4700689eb5c93124dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6748d65245713aa45559963c8488bf17"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a6748d65245713aa45559963c8488bf17">BlockEnQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, const UInt8 *pData, UInt32 Size)</td></tr>
<tr class="separator:a6748d65245713aa45559963c8488bf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95e1136358e00f80da8453849c59188"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#aa95e1136358e00f80da8453849c59188">BlockEnQFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, const UInt8 *pData, UInt32 Size)</td></tr>
<tr class="separator:aa95e1136358e00f80da8453849c59188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc1e5f74c6cceea5104f947e87c26c9"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a9fc1e5f74c6cceea5104f947e87c26c9">BlockQTransfer</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pRxQ, <a class="el" href="structQueue__t.html">Queue_t</a> *pTxQ, UInt32 Size)</td></tr>
<tr class="separator:a9fc1e5f74c6cceea5104f947e87c26c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2523aa6b9399dad9881e8e0a1a999266"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a2523aa6b9399dad9881e8e0a1a999266">BlockQTransferFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pRxQ, <a class="el" href="structQueue__t.html">Queue_t</a> *pTxQ, UInt32 Size)</td></tr>
<tr class="separator:a2523aa6b9399dad9881e8e0a1a999266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba59129011e4cbdddbb31d5da4b793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a65ba59129011e4cbdddbb31d5da4b793">BlockEnQSmall</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, const UInt8 *pData, UInt32 Size)</td></tr>
<tr class="separator:a65ba59129011e4cbdddbb31d5da4b793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7b65c683be840c09c402a3150a3fdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a6d7b65c683be840c09c402a3150a3fdf">BlockEnQSmallFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, const UInt8 *pData, UInt32 Size)</td></tr>
<tr class="separator:a6d7b65c683be840c09c402a3150a3fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212ed77c30e8284f0274349b1d8867dd"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a212ed77c30e8284f0274349b1d8867dd">ReverseEnQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt32 Size)</td></tr>
<tr class="separator:a212ed77c30e8284f0274349b1d8867dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606fe7b97e68e06ec56e28da59f81da5"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a606fe7b97e68e06ec56e28da59f81da5">ReverseEnQFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt32 Size)</td></tr>
<tr class="separator:a606fe7b97e68e06ec56e28da59f81da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02b7dee368f606259d12b4295beced4"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#af02b7dee368f606259d12b4295beced4">QAvailable</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:af02b7dee368f606259d12b4295beced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99596f7e31721da7962a36813570907c"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a99596f7e31721da7962a36813570907c">QAvailableFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:a99596f7e31721da7962a36813570907c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8fd0970409ecc2ba6a71d82ba95735"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#aae8fd0970409ecc2ba6a71d82ba95735">QHolding</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:aae8fd0970409ecc2ba6a71d82ba95735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e0e544987dec0988968437cd80c2df"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a50e0e544987dec0988968437cd80c2df">QHoldingFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:a50e0e544987dec0988968437cd80c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08fe9e1d0f052cb6b7607bdae29216e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#af08fe9e1d0f052cb6b7607bdae29216e">IsQFull</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:af08fe9e1d0f052cb6b7607bdae29216e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a5a7e6ac300123af2d87f0aba8563"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a810a5a7e6ac300123af2d87f0aba8563">IsQFullFast</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:a810a5a7e6ac300123af2d87f0aba8563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdeaf97dfd3366f1cba88eb221583af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#a4bdeaf97dfd3366f1cba88eb221583af">ResetQ</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ)</td></tr>
<tr class="separator:a4bdeaf97dfd3366f1cba88eb221583af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca1836daa967f2444b58ae733fc813a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Queue_8h.html#aeca1836daa967f2444b58ae733fc813a">ResetQEx</a> (<a class="el" href="structQueue__t.html">Queue_t</a> *pQ, UInt32 Value)</td></tr>
<tr class="separator:aeca1836daa967f2444b58ae733fc813a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8993d1b0c2ad7377d0a5e00149c4eca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8993d1b0c2ad7377d0a5e00149c4eca7"></a>
UInt32&#160;</td><td class="memItemRight" valign="bottom"><b>BackupQueueIndex</b> (UInt32 In, UInt32 Out, UInt32 Size, UInt32 Backup)</td></tr>
<tr class="separator:a8993d1b0c2ad7377d0a5e00149c4eca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>First in first out ring buffer queues for 8-bit data. </p>
<p>The queue module defines a basic ring buffer format and functions for adding data (EnQ) and removing data (DeQ). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acd462a4f5135461aa18fc6e6e7552ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 BlockDeQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a block of the oldest data from the passed queue. This routine uses block memory transfers and is faster than calling DeQ multiple times. The actual number of bytes dequeued is returned. This may be less than Size if the queue does not hold enough bytes to complete the transaction. If the queue pointer is invalid this function returns 0; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>points to a buffer to receive the data. </td></tr>
    <tr><td class="paramname">Size</td><td>is the number of bytes to dequeue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes dequeued. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a63dcebd0a612619b8149ac1905b4b5ab">BlockDeQFast()</a>.</p>

<p>Referenced by <a class="el" href="classCctSocket.html#a012ae6ccb701ee0c39abd93a9d8bf7d6">CctSocket::read()</a>, <a class="el" href="Serial_8h.html#a074807fc455a5b0941c8b93244d571bc">ReadBlockQuick()</a>, and <a class="el" href="classCctSocket.html#acd58665103f0fc97612bc75a00aabb86">CctSocket::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a63dcebd0a612619b8149ac1905b4b5ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 BlockDeQFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a block of the oldest data from the passed queue. This routine uses block memory transfers and is faster than calling <a class="el" href="Queue_8h.html#abe54943f8deb0ebb76cab0642c47772f">DeQ()</a> multiple times. The actual number of bytes dequeued is returned. This may be less than Size if the queue does not hold enough bytes to complete the transaction. This function is faster than <a class="el" href="Queue_8h.html#acd462a4f5135461aa18fc6e6e7552ded">BlockDeQ()</a> since it does not check for a valid queue pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>points to a buffer to receive the data. </td></tr>
    <tr><td class="paramname">Size</td><td>is the number of bytes to dequeue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes dequeued. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, <a class="el" href="structQueue__t.html#ac1029dee2062c45dfd0b5eb05e426660">Queue_t::pBuf</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#acd462a4f5135461aa18fc6e6e7552ded">BlockDeQ()</a>, <a class="el" href="StreamPackets_8h.html#ae30d611202d103c180428d6751102790">LookForCANPacket()</a>, <a class="el" href="GimbalPacket_8h.html#a2a331e73dbab4602293d07c8efd898dc">LookForGimbalPacketInQueue()</a>, <a class="el" href="StreamPackets_8h.html#a578a11a8053bbab2eb84b9fcc7228906">LookForSimplePacket()</a>, and <a class="el" href="stream_8h.html#adac76228d6effee9b6271cf7d5165e27">LookForStreamPacketInQueue()</a>.</p>

</div>
</div>
<a class="anchor" id="a6748d65245713aa45559963c8488bf17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 BlockEnQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UInt8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a block of bytes to the queue. This function is faster than calling EnQ multiple times since it performs block memory transfers. The block transfer will be truncated to fit within the available space on the queue. The remaining free space on the queue is returned. This function incurs significant overhead and should only be used when large chunks of data are being moved. Small blocks of data should be moved using <a class="el" href="Queue_8h.html#a65ba59129011e4cbdddbb31d5da4b793">BlockEnQSmall()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>points to a buffer of data to be added to the queued. </td></tr>
    <tr><td class="paramname">Size</td><td>is the amount of data to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes enqueued. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#aa95e1136358e00f80da8453849c59188">BlockEnQFast()</a>.</p>

<p>Referenced by <a class="el" href="Network_8h.html#a2ffd651a7767f2ab59019da363bcce80">QueueDataForTransmit()</a>, <a class="el" href="classCctSocket.html#a012ae6ccb701ee0c39abd93a9d8bf7d6">CctSocket::read()</a>, and <a class="el" href="classCctSocket.html#acd58665103f0fc97612bc75a00aabb86">CctSocket::write()</a>.</p>

</div>
</div>
<a class="anchor" id="aa95e1136358e00f80da8453849c59188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 BlockEnQFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UInt8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a block of bytes to the queue. This function is faster than calling EnQ multiple times since it performs block memory transfers. The block transfer will be truncated to fit within the available space on the queue. The remaining free space on the queue is returned. This function incurs significant overhead and should only be used when large chunks of data are being moved. Small blocks of data should be moved using <a class="el" href="Queue_8h.html#a65ba59129011e4cbdddbb31d5da4b793">BlockEnQSmall()</a>. This function is faster than <a class="el" href="Queue_8h.html#a6748d65245713aa45559963c8488bf17">BlockEnQ()</a> since it does not check if the queue pointer is valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>points to a buffer of data to be added to the queued. </td></tr>
    <tr><td class="paramname">Size</td><td>is the amount of data to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes enqueued. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#ac1029dee2062c45dfd0b5eb05e426660">Queue_t::pBuf</a>, <a class="el" href="Queue_8h.html#a99596f7e31721da7962a36813570907c">QAvailableFast()</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#a6748d65245713aa45559963c8488bf17">BlockEnQ()</a>.</p>

</div>
</div>
<a class="anchor" id="a65ba59129011e4cbdddbb31d5da4b793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BlockEnQSmall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UInt8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a small block of bytes to the queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>points to a buffer of data to be added to the queued. </td></tr>
    <tr><td class="paramname">Size</td><td>is the amount of data to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Queue_8h.html#a6d7b65c683be840c09c402a3150a3fdf">BlockEnQSmallFast()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d7b65c683be840c09c402a3150a3fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BlockEnQSmallFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UInt8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a small block of bytes to the queue. This function is faster than <a class="el" href="Queue_8h.html#a65ba59129011e4cbdddbb31d5da4b793">BlockEnQSmall()</a> since it does not check if the queue pointer is valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">pData</td><td>points to a buffer of data to be added to the queued. </td></tr>
    <tr><td class="paramname">Size</td><td>is the amount of data to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Queue_8h.html#af291243469b7aa1b704317e199407abd">EnQSuperFast()</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#a65ba59129011e4cbdddbb31d5da4b793">BlockEnQSmall()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc1e5f74c6cceea5104f947e87c26c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 BlockQTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pRxQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pTxQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move data directly from one queue to another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRxQ</td><td>gets new data. </td></tr>
    <tr><td class="paramname">pTxQ</td><td>gives data up. </td></tr>
    <tr><td class="paramname">Size</td><td>is the amount of data to transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of data transferred. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a2523aa6b9399dad9881e8e0a1a999266">BlockQTransferFast()</a>.</p>

</div>
</div>
<a class="anchor" id="a2523aa6b9399dad9881e8e0a1a999266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 BlockQTransferFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pRxQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pTxQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move data directly from one queue to another. The data move will be truncated according to the space available in pRxQ and data held in pTxQ. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRxQ</td><td>gets new data, must not be NULL. </td></tr>
    <tr><td class="paramname">pTxQ</td><td>gives data up, must not be NULL. </td></tr>
    <tr><td class="paramname">Size</td><td>is the amount of data to transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of data transferred. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, <a class="el" href="structQueue__t.html#ac1029dee2062c45dfd0b5eb05e426660">Queue_t::pBuf</a>, <a class="el" href="Queue_8h.html#a99596f7e31721da7962a36813570907c">QAvailableFast()</a>, <a class="el" href="Queue_8h.html#a50e0e544987dec0988968437cd80c2df">QHoldingFast()</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#a9fc1e5f74c6cceea5104f947e87c26c9">BlockQTransfer()</a>.</p>

</div>
</div>
<a class="anchor" id="a33605d1c942e81951eecc51f66cef7af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structQueue__t.html">Queue_t</a>* CreateQ </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a queue by dynamically allocating memory for the queue structure and buffer; and initializing In, Out, and Size elements of the queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Size</td><td>is one more than the number of elements the queue buffer can hold </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the queue. NULL is returned if the queue could not be allocated. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, <a class="el" href="structQueue__t.html#ac1029dee2062c45dfd0b5eb05e426660">Queue_t::pBuf</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="classCctSocket.html#aacacb93b499d09752ab7038e3a380f93">CctSocket::open()</a>, <a class="el" href="Serial_8h.html#a411befec02113ce5dbb3fca6955bf723">OpenCOMM()</a>, <a class="el" href="Serial_8h.html#a16459595cbe091170b7be50a6c1d8ff7">OpenCOMMDev()</a>, and <a class="el" href="Network_8h.html#a596c5318cea55d1220f2514173829cef">OpenStream()</a>.</p>

</div>
</div>
<a class="anchor" id="abe54943f8deb0ebb76cab0642c47772f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SInt16 DeQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the oldest 8 bit data in the queue, removing the data from the queue. If the queue is empty -1 is returned. This function will return -1 if the queue pointer is invalid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The oldest data in the queue, or -1 if the queue is empty. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a7260b3138e9acc3591b2b95e2c4efcab">DeQFast()</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#a7260b3138e9acc3591b2b95e2c4efcab">DeQFast()</a>, and <a class="el" href="Serial_8h.html#a0646d2af96a66f2d4e36bcbd374e8003">ReadByteQuick()</a>.</p>

</div>
</div>
<a class="anchor" id="a7260b3138e9acc3591b2b95e2c4efcab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SInt16 DeQFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the oldest 8 bit data in the queue, removing the data from the queue. If the queue is empty -1 is returned. This function is faster than <a class="el" href="Queue_8h.html#abe54943f8deb0ebb76cab0642c47772f">DeQ()</a> because it does not check for a valid queue pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The oldest data in the queue, or -1 if the queue is empty. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#abe54943f8deb0ebb76cab0642c47772f">DeQ()</a>, <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, <a class="el" href="structQueue__t.html#ac1029dee2062c45dfd0b5eb05e426660">Queue_t::pBuf</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#abe54943f8deb0ebb76cab0642c47772f">DeQ()</a>, <a class="el" href="StreamPackets_8h.html#ae30d611202d103c180428d6751102790">LookForCANPacket()</a>, <a class="el" href="GimbalPacket_8h.html#a2a331e73dbab4602293d07c8efd898dc">LookForGimbalPacketInQueue()</a>, <a class="el" href="StreamPackets_8h.html#a578a11a8053bbab2eb84b9fcc7228906">LookForSimplePacket()</a>, <a class="el" href="stream_8h.html#adac76228d6effee9b6271cf7d5165e27">LookForStreamPacketInQueue()</a>, and <a class="el" href="Serial_8h.html#ae48302e59b5bb5f163513596ff195182">WriteFromQueueQuick()</a>.</p>

</div>
</div>
<a class="anchor" id="a7fea93c75bda73855de0af7ff9b3f1e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DestroyQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the memory associated with a queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with CreateQ. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classCctSocket.html#ab1b951d12dfaa86090a0d98b61e26be1">CctSocket::close()</a>, <a class="el" href="Serial_8h.html#a59c2a6bf21d3e35e3aa2d50c8d172bdc">CloseCOMM()</a>, <a class="el" href="Network_8h.html#ac2057e07e64d0820d01807a3bb931467">CloseStream()</a>, and <a class="el" href="Network_8h.html#a596c5318cea55d1220f2514173829cef">OpenStream()</a>.</p>

</div>
</div>
<a class="anchor" id="a2384132c5c0d4700689eb5c93124dbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt8&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a byte to the queue. The remaining free space on the queue is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Data</td><td>is the new data to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Queue_8h.html#af291243469b7aa1b704317e199407abd">EnQSuperFast()</a>.</p>

</div>
</div>
<a class="anchor" id="ac520b06dbb8d4f0cf5fc5c560202a996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnQFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt8&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a byte to the queue. This function is faster than <a class="el" href="Queue_8h.html#a2384132c5c0d4700689eb5c93124dbfa">EnQ()</a> since it doesn't return the free space remaining on the queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Data</td><td>is the new data to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Queue_8h.html#af291243469b7aa1b704317e199407abd">EnQSuperFast()</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#af291243469b7aa1b704317e199407abd">EnQSuperFast()</a>.</p>

</div>
</div>
<a class="anchor" id="af291243469b7aa1b704317e199407abd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnQSuperFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt8&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a byte to the queue. This function is faster than <a class="el" href="Queue_8h.html#ac520b06dbb8d4f0cf5fc5c560202a996">EnQFast()</a> since it doesn't check for a valid queue pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Data</td><td>is the new data to add. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="Queue_8h.html#ac520b06dbb8d4f0cf5fc5c560202a996">EnQFast()</a>, <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, <a class="el" href="structQueue__t.html#ac1029dee2062c45dfd0b5eb05e426660">Queue_t::pBuf</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#a6d7b65c683be840c09c402a3150a3fdf">BlockEnQSmallFast()</a>, <a class="el" href="Queue_8h.html#a2384132c5c0d4700689eb5c93124dbfa">EnQ()</a>, and <a class="el" href="Queue_8h.html#ac520b06dbb8d4f0cf5fc5c560202a996">EnQFast()</a>.</p>

</div>
</div>
<a class="anchor" id="af08fe9e1d0f052cb6b7607bdae29216e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL IsQFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if a queue is full. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the queue is full, else FALSE </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a810a5a7e6ac300123af2d87f0aba8563">IsQFullFast()</a>.</p>

</div>
</div>
<a class="anchor" id="a810a5a7e6ac300123af2d87f0aba8563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL IsQFullFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if a queue is full. This function is faster than <a class="el" href="Queue_8h.html#af08fe9e1d0f052cb6b7607bdae29216e">IsQFull()</a> since it does not check if the queue pointer is valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the queue is full, else FALSE </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a50e0e544987dec0988968437cd80c2df">QHoldingFast()</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#af08fe9e1d0f052cb6b7607bdae29216e">IsQFull()</a>.</p>

</div>
</div>
<a class="anchor" id="af02b7dee368f606259d12b4295beced4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 QAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the amount of space available on the queue. An empty queue will have Size-1 bytes available. This is because 1 byte of the buffer is used for overflow detection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The space available on the queue. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a99596f7e31721da7962a36813570907c">QAvailableFast()</a>.</p>

<p>Referenced by <a class="el" href="classCctSocket.html#a012ae6ccb701ee0c39abd93a9d8bf7d6">CctSocket::read()</a>, and <a class="el" href="classCctSocket.html#acd58665103f0fc97612bc75a00aabb86">CctSocket::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a99596f7e31721da7962a36813570907c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 QAvailableFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the amount of space available on the queue. An empty queue will have Size-1 bytes available. This is because 1 byte of the buffer is used for overflow detection. This function is faster than <a class="el" href="Queue_8h.html#af02b7dee368f606259d12b4295beced4">QAvailable()</a> since it does not check if the queue pointer is valid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The space available on the queue. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#aa95e1136358e00f80da8453849c59188">BlockEnQFast()</a>, <a class="el" href="Queue_8h.html#a2523aa6b9399dad9881e8e0a1a999266">BlockQTransferFast()</a>, <a class="el" href="Queue_8h.html#af02b7dee368f606259d12b4295beced4">QAvailable()</a>, and <a class="el" href="Queue_8h.html#a0be71d93fc5d5f35042c52d3c179ae9c">ReverseDeQFast()</a>.</p>

</div>
</div>
<a class="anchor" id="aae8fd0970409ecc2ba6a71d82ba95735"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 QHolding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the amount of data on the queue. A full queue will hold Size-1 bytes available. This is because 1 byte of the buffer is used for overflow detection. Zero will be returned if the queue is invalid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of data on the queue. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a50e0e544987dec0988968437cd80c2df">QHoldingFast()</a>.</p>

<p>Referenced by <a class="el" href="Serial_8h.html#ac24160d0743ede3b933a8de2de20015d">RxQHolding()</a>, <a class="el" href="Serial_8h.html#ae97ef468f8b3d2037831abc2f130c80f">TxQAvailable()</a>, and <a class="el" href="classCctSocket.html#acd58665103f0fc97612bc75a00aabb86">CctSocket::write()</a>.</p>

</div>
</div>
<a class="anchor" id="a50e0e544987dec0988968437cd80c2df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 QHoldingFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the amount of data on the queue. A full queue will hold Size-1 bytes available. This is because 1 byte of the buffer is used for overflow detection. This function is faster than <a class="el" href="Queue_8h.html#aae8fd0970409ecc2ba6a71d82ba95735">QHolding()</a> because it does not check for a valid queue pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of data on the queue. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#a2523aa6b9399dad9881e8e0a1a999266">BlockQTransferFast()</a>, <a class="el" href="Queue_8h.html#a810a5a7e6ac300123af2d87f0aba8563">IsQFullFast()</a>, <a class="el" href="Queue_8h.html#aae8fd0970409ecc2ba6a71d82ba95735">QHolding()</a>, <a class="el" href="Queue_8h.html#a606fe7b97e68e06ec56e28da59f81da5">ReverseEnQFast()</a>, and <a class="el" href="Serial_8h.html#ae48302e59b5bb5f163513596ff195182">WriteFromQueueQuick()</a>.</p>

</div>
</div>
<a class="anchor" id="a4bdeaf97dfd3366f1cba88eb221583af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResetQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the queue index variables, discarding any data in the queue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, and <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>.</p>

<p>Referenced by <a class="el" href="Network_8h.html#a0de8af23164cc3a24507d8243c133f06">ResetNetworkBuffers()</a>.</p>

</div>
</div>
<a class="anchor" id="aeca1836daa967f2444b58ae733fc813a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResetQEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the queue index variables, discarding any data in the queue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Value</td><td>is the value that the In an Out index variables will be assigned. Note that the actual value of In and Out will be ValuepQ-&gt;Size. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

</div>
</div>
<a class="anchor" id="a263d0bc6499f82331868576aa095592d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 ReverseDeQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse the DeQ process, effectively putting bytes back on the queue. All we are actually doing is moving the out pointer backwards so that it will return bytes we've already DeQueued. The queue will only reverse up to the newest data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Size</td><td>is the number of bytes to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes reversed. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a0be71d93fc5d5f35042c52d3c179ae9c">ReverseDeQFast()</a>.</p>

<p>Referenced by <a class="el" href="Serial_8h.html#affcb030b590d2a583fdfae3b8a8d1095">ReverseSerialRxQueue()</a>.</p>

</div>
</div>
<a class="anchor" id="a0be71d93fc5d5f35042c52d3c179ae9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 ReverseDeQFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse the DeQ process, effectively putting bytes back on the queue. All we are actually doing is moving the out pointer backwards so that it will return bytes we've already DeQueued. The queue will only reverse up to the newest data. This function is faster than <a class="el" href="Queue_8h.html#a263d0bc6499f82331868576aa095592d">ReverseDeQ()</a> since it doesn't check for a valid queue pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Size</td><td>is the number of bytes to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes reversed. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a0f79cba01b0e4b0ee17045febc2cd5b9">Queue_t::Out</a>, <a class="el" href="Queue_8h.html#a99596f7e31721da7962a36813570907c">QAvailableFast()</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="StreamPackets_8h.html#ae30d611202d103c180428d6751102790">LookForCANPacket()</a>, <a class="el" href="StreamPackets_8h.html#a578a11a8053bbab2eb84b9fcc7228906">LookForSimplePacket()</a>, <a class="el" href="stream_8h.html#adac76228d6effee9b6271cf7d5165e27">LookForStreamPacketInQueue()</a>, and <a class="el" href="Queue_8h.html#a263d0bc6499f82331868576aa095592d">ReverseDeQ()</a>.</p>

</div>
</div>
<a class="anchor" id="a212ed77c30e8284f0274349b1d8867dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 ReverseEnQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse the EnQ process, effectively destroying the oldest bytes on the queue. All we are actually doing is moving the in pointer backwards so that it loses bytes we've queued. The queue will only reverse up to the oldest data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Size</td><td>is the number of bytes to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes reversed. </dd></dl>

<p>References <a class="el" href="Queue_8h.html#a606fe7b97e68e06ec56e28da59f81da5">ReverseEnQFast()</a>.</p>

</div>
</div>
<a class="anchor" id="a606fe7b97e68e06ec56e28da59f81da5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 ReverseEnQFast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structQueue__t.html">Queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse the EnQ process, effectively destroying the oldest bytes on the queue. All we are actually doing is moving the in pointer backwards so that it loses bytes we've queued. The queue will only reverse up to the oldest data. This function is faster than <a class="el" href="Queue_8h.html#a212ed77c30e8284f0274349b1d8867dd">ReverseEnQ()</a> since it does not check if the queue pointer is valid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQ</td><td>points to a queue that was previously created with <a class="el" href="Queue_8h.html#a33605d1c942e81951eecc51f66cef7af">CreateQ()</a>. </td></tr>
    <tr><td class="paramname">Size</td><td>is the number of bytes to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes reversed. </dd></dl>

<p>References <a class="el" href="structQueue__t.html#a529fd249903bb57703b557d2465b8c85">Queue_t::In</a>, <a class="el" href="Queue_8h.html#a50e0e544987dec0988968437cd80c2df">QHoldingFast()</a>, and <a class="el" href="structQueue__t.html#ac245681ea835c283f6835abb2355cf2d">Queue_t::Size</a>.</p>

<p>Referenced by <a class="el" href="Queue_8h.html#a212ed77c30e8284f0274349b1d8867dd">ReverseEnQ()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_919b5d268a6a4b1f397ff58109581cdf.html">Serial</a></li><li class="navelem"><a class="el" href="Queue_8h.html">Queue.h</a></li>
    <li class="footer">Generated on Wed Aug 2 2017 09:25:44 for Communications SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
